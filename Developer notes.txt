Every component to have state and to tell React what there's been a change we use hook useState

UseState - this is array wich two meanings:
    first meaning: set value
    second meaning: state changing function

------------------CODE------------------

import React, { useState } from 'react';

function App() {
  const [likes, setLikes] = useState(0); //useState hook

  // a function that increments the "likes" variable by 1
  function increment() {
    setLikes(likes + 1);
  }

  // a function that decrements the "likes" variable by 1
  function decrement() {
    setLikes(likes - 1);
  }

  return (
    <div className="App">
      <h1>{likes}</h1>
      <button onClick={increment}>Increment</button> {/* button that increases the number by 1 */}
      <button onClick={decrement}>Decrement</button> {/* button that decrease the number by 1 */}
    </div>
  );
}

export default App;

------------------/CODE------------------


Managed component is component whose value we can change by changing its state.

OnChange 

------------------CODE------------------

import React, { useState } from 'react';
function App() { 
  const [likes, setLikes] = useState(0); //useState hook
  const [value, setValue] = useState('TEXT in input')

  // a function that increments the "likes" variable by 1
  function increment() {
    setLikes(likes + 1);
  }

  // a function that decrements the "likes" variable by 1
  function decrement() {
    setLikes(likes - 1);
  }
  
 
  console.log(value);


  return (
    <div className="App">
      <h1>{likes}</h1>
      <h1>{value}</h1>
      <input 
        type="text" value={likes} 
        onChange={event => setValue(event.target.value)}
      
      />
      <button onClick={increment}>Increment</button> {/* button that increases the number by 1 */}
      <button onClick={decrement}>Decrement</button> {/* button that decrease the number by 1 */}
    </div>
  );
}

export default App;
------------------/CODE------------------

//Function counter
------------------CODE-------------------
import React, { useState } from 'react'

export default function App() {
  const [count, setCount] = useState(0)

  function inc() {
    setCount(count + 1)
  }
  
  console.log(count);
  return (
    <div>
      <h2>{count}</h2>
      <button onClick={inc}>+</button>
      <button onClick={() => setCount(count - 1)}>-</button>
    </div>
  )
}
------------------/CODE-------------------

Callback - is function transferred in other function as an arqument


// Class counter
------------------CODE-------------------
import React, { Component } from 'react'

export default class ClassFlugger extends Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    }
  }

  render() {
    return (
      <div>
        <h2>{this.state.count}</h2>
        <button onClick={() => this.setState({count: this.state.count + 1}) }>+</button>
        <button onClick={() => this.setState({count: this.state.count - 1}) }>-</button>
      </div>
    )
  }
}
------------------/CODE-------------------


Props - это обьект в который я могу заворачивать аргументы и передовать его в компоненты это позвляет мне их переиспользовать и коректировать изменяемые значения такие как заголовок поста под конкретный случай или например добавить два поста в файле App.js и каждому указать уникальное название и контент используя аргументы
------------------CODE-------------------
// App.js 
import React from 'react'
import ClassFlugger from './components/ClassFlugger'
import Flugger from './components/Flugger'
import Post from './components/Post'
import './styles/App.css'

export default function App() {
  return (
    <div className='App'>
      <Post post={{id: 1, title: 'Golang', body: 'Description'}}/>
    </div>
  )
}    
  


// PostItems.jsx
import React from 'react'
import '../styles/App.css'


export default function Post(props) {
  console.log(props)
  return (
    <div className='Post'>
      <div className='Post__content'>
          <strong>{props.post.id}, {props.post.title}</strong>
          <div>
            {props.post.body}
          </div>
          <div className='Post__buttons'>
            <button>Post</button>
            <button>Delete</button>
          </div>
        </div>  
    </div>
  )
}

------------------/CODE-------------------


Преобразование масива с элементами в массив с React компонентами
------------------CODE-------------------
// App.js
import React, { useState } from 'react';

import ClassFlugger from './components/ClassFlugger'
import Flugger from './components/Flugger'
import PostItems from './components/PostItems'
import './styles/App.css'

export default function App() {
    const [posts, setPosts] = useState([
      {id: 0, title: 'Golang it', description: 'Description'},  //element
      {id: 1, title: 'Golang it1', description: 'Description'}, //element
      {id: 2, title: 'Golang it2', description: 'Description'}  //element
    ]);


    return (
    <div className='App'>
      <h1 style={{textAlign: 'center'}}>Posts List</h1>
      {posts.map(post => 
        <PostItems post={post} key={post.id} />
      )}
    </div>
  )
}

// PostItems.jsx
import React, { useState } from 'react';

export default function PostItems(props) {
  return (
    <div>
      <div className="PostItems">
        <div className="PostItems__content">
          <header>{props.post.id}. {props.post.title}</header>
          <div className="PostItems__description">{props.post.description}</div>
          <div className="PostItems__buttons">
            <button>Create</button>
            <button>Delete</button>
          </div>
        </div>
      </div>
    </div>
  )
}

------------------/CODE-------------------    

Standart css styles for button
------------------CODE-------------------
//App.css
button {
  position: relative;
  display: inline-block;
  cursor: pointer;
  outline: none;
  border: 0;
  vertical-align: middle;
  text-decoration: none;
  font-size: inherit;
  font-family: inherit;
}
------------------/CODE-------------------

How make UI component?
Don't never use margin and positioning styles inside a component
If I want to use a margin styles for component I just add this component in Block and to that block margin styles
Do the same with the width for the component
If component to use buiznes logic don't use state inside a component  
Don't pass function in props inside a component
Use PropTipes

70% information we remember when participate in discussions
90% information we remember when to worked and imitate a real work
info@ingrad.com 
rabota@ingrad.com - РАБОТА 


https://webgolovolomki.com/kak-sdelat-effekt-nazhatiya-knopki-na-css/ гайд по анимации кнопок

I can write down props intresting method:
Insofar as props this object I can not write 'props' in arquments my component, but I can write down '{}' and write down inside these brackets name needing me parameter

EXAMPLE:
instead of this:
------------------CODE--------------------
//PostList.jsx 
import React from 'react';
import PostItem from '../PostItem/PostItem'

export default function PostList(props) {
  console.log(props);
  return (
    <div>
      <h1 style={{textAlign: 'center'}}>
        {props.title}
      </h1>
      {props.posts.map((post) => 
        <PostItem post={post} key={props.id} />
      )}
    </div>
  )
}
------------------/CODE-------------------
it:
------------------CODE--------------------
//PostList.jsx 
import React from 'react';
import PostItem from '../PostItem/PostItem'
// {posts, title, id}
export default function PostList({posts, title, id}) {
  console.log(props);
  return (
    <div>
      <h1 style={{textAlign: 'center'}}>
        {title}
      </h1>
      {posts.map((post) => 
        <PostItem post={post} key={id} />
      )}
    </div>
  )
}
------------------/CODE-------------------  

I can to reset styles just importing normalize styles file
------------------CODE--------------------
@import-normalize;
------------------/CODE-------------------


Хуки можно вкладывать только в верхний уровень вложенности, то есть их нельзя вкладывать в функции и т.д.


Как отрисовать несколько компонентов на основании массива?
Создаю useState в него помещаю массив, а в этот массив сколько мне нужно обьектов даю этим обьектам поля со свойствами в данном случае это title: со заначением 'title', body: со значением 'decription' далее вызываю в коде JSX переменную useState-а обращаюсь через точку к функции map и передаю аргументом функцию (callback), которая принимает аргкментом обьект который map создаст, его можно назвать как угодно далее в круглых скобках укажи JSX который ты хочешь отрисовать вместо обьекта в массиве
-------------------CODE-------------------
//App.js
import { useState } from 'react';
import PostItem from './components/PostItem/PostItem';
import './styles/App.css';

function App() {
  const [posts, setPosts] = useState([
    { id: 1, title: 'JavaScrpt', body: 'description' },
    { id: 2, title: 'JavaScrpt 2', body: 'description' },
    { id: 3, title: 'JavaScrpt 3', body: 'description' },
  ]);

  return (
    <div className="App">
      <h1 style={{ textAlin: 'center' }}>Post list</h1>
      {posts.map((post) => (
        <PostItem post={post} key={post.id} />
      ))}
    </div>
  );
}

export default App;

//PostItem.jsx
import React from 'react';

export default function PostItem(props) {
  return (
    <div className="post">
      <div className="post__content">
        <strong>
          {props.post.id}. {props.post.title}
        </strong>
        <div>{props.post.body}</div>
      </div>
      <div className="post__btns">
        <button>Delete</button>
      </div>
    </div>
  );
}
------------------/CODE-------------------
В React при создании списка обязательно указывай свойство key для каждого элемента списка причем значение key обязательно делай уникальным и не используй index массива для этого


Как сделать инпут управляемым?
Создаю useState и в свойствах input прописываю value={/*переменная useState*/} далее пишу свойство onChange(e => /*функция useState*/(e.target.value))


ALWAIS write import { useState } from 'react' instead of import useState from 'react'

Внутри дочернего компонента я не имею доступ к состоянию родительмкого, а поскольку пропсы можно передовать только от родителя к ребенку я применю хитрость создав в родительском компоненте функцию которую я передам пропсом в дочерний компонент там её вызову передав в эту функцию параметрамами данные котые я хочу передать к родительскому компоненту

Как отрисовать надпись при отсутвстиви постов?
Логика: Если постов нет отрисовать "Посты не найдены" еще логичнее: если длина массива с постами ровна нулю отрендерить <div>Посты не найдены</div>
-------------------CODE-------------------

{posts.length !== 0 ? (
  <PostList remove={removePost} posts={posts} title={'Post list'} />
) : (
  <h2 style={{ textAlign: 'center' }}>Посты не найдены!</h2>
)}

------------------/CODE-------------------


Как сделать компонент упровляемым?
Для этого используеться:
useState
value - свойство компонента
onChange

Реализация через обьект
1:
Создаю useState, помещаю в него обьект с нужными полями в данном случае title и body, их я приравниваю к пустой строке
2: 
Вешаю на компонент onChange это функция, которая отслеживает взаимодействие пользователя и компонента например нажатие или ввод символа в ней пишу стрелоную функцию которая принимает event (сокрощенно e) и которая вызывает функцию изменения состояния useState в которой я разворачиваю все поля обьекта post (ведь я прописал что useState равен обьекту и дал этому обьекту поля title и body) а дальше я преписываю нужное мне поле в данном случае title с пустой строки на значение этого компонента командой 'e.target.value' 
e - сокращение event 
target - сам компонент с которым происходит event то есть событие 
value свойство этого компонента которое мы приравниваем к обьекту пост командой 'value={post}'
-------------------CODE-------------------
//PostForm.jsx

import { useState } from 'react';
import Input from '../UI components/Input/Input';
import Button from '../UI components/Button/Button';

const PostForm = ({ create }) => {
  const [post, setPost] = useState({ title: '', body: '' });

  const addNewPost = (e) => {
    e.preventDefault();
    const newPost = {
      ...post,
      id: Date.now(),
    };
    create(newPost);
    setPost({ title: '', body: '' });
  };

  return (
    <form>
      <Input
        type="text"
        value={post.title} // то самое value в данном случае компонента Input 
        onChange={(e) => setPost({ ...post, title: e.target.value })} // тот самый onChange
        placeholder="Post name"
      />
      <Input
        type="text"
        value={post.body}
        onChange={(e) => setPost({ ...post, body: e.target.value })}
        placeholder="Post description"
      />
      <Button onClick={addNewPost} disablded="true">
        Create post
      </Button>
    </form>
  );
};

export default PostForm;

------------------/CODE-------------------


Я могу реализовать двухсторонее связывание нужного мне DOW элемента даже если я вынес его в отдельный коспонент для этого я просто передаю onChange пропсами, принимаю его в компоненте и работаю с ним так как будто он внутри этого тега

Я добавил возможность переходить на отдельную страницу поста, кликнув на кнопку 'открыть', но пока там ничего не отрисовываеться, а я хочу отрисовать там заголовок с title поста на которой я кликнул.
Раньше я это делал просто получая все посты в самом компоненте <SinglePage>, но в проекте из фундаментального курса по React я получаю все посты в компоненте <PostList>, передовать их оттуда в <SinglePage> будет слишком сложно.
Поэтому я решил выцеплять из адресной строки браузера id поста на который я перешел и на его основании делать отдельный запрос на сервер для получения поста с тем же id, что и у того на который я перешел
Выцеплять я его могу, используя хук useParams 

В <SinglePostPage> создай литерал обьекта через константу и в этом литерале получи id, присвой этому всему вызов функции useParams.

-------------------CODE-------------------
import { useParams } from 'react-router-dom';

export default function SinglePostPage() {
  const { id } = useParams();

  return (
    <div>SinglePostPage</div>
  );
}
------------------/CODE-------------------

Для получения постов ранее создал отдельный API сервис <PostService> сейчас я снова им воспользуюсь
Создай в файле <PostService> новую функцию getPostById сделай её такой же, что функция getAll, только без параметров запроса и к поисковой строке добавь id поста на который ты перешел и к самому пути в его конце добавь /, а также прими id в этой функции

-------------------CODE-------------------
//PostService.jsx
import axios from 'axios';

export default class PostService {
  static async getAll(limit = 10, page = 1) {
    const response = await axios.get(
      'https://jsonplaceholder.typicode.com/posts',
      {
        params: {
          _limit: limit,
          _page: page,
        },
      }
    );
    return response;
  }

  static async getPostById(id) {
    const response = await axios.get(
      'https://jsonplaceholder.typicode.com/posts/' + id
    );
    return response;
  }
}
------------------/CODE-------------------

В компоненте <SinglePostPage> создай состояние post, через useState и помести в него пустой обьект.

Там же используй свой кастомный хук useFetching, создай массив с элементами fetchPostById, isLoading и error, присвой ему вызов хука useFetching и в него параметром передай функцию callback, сделай её асинхронной, указав async перед её списком параметров. 
В её же теле создай константу response и присвой ей вызов метода getPostById класса PostServiсe и в него передай id полученный через хук useParams, незабудь указать await перед PostService, а также в её теле измени состояние post на response.data

Используй хук useEffect, в его теле вызови, полученную через хук useFetching функцию fetchPostById, незабудь импортировать его

ВОТ И ВСЁ тот самый пост, который я открыл я получил теперь реализуй отрисовку его title и body, только с отрисовкой лоадера

Для этого по схеме реализуй условную отрисовку на основании значения isLoading, полученного через хук useFetching, использовав тернарный опрератор ? - если isLoading true, то отрисовать компонент <Loader> если false, то отрисовать div с заголовком и телом поста

-------------------CODE-------------------
//SinglePostPage.jsx

import { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import PostService from '../../API/PostService';
import Loader from '../../components/UI components/Loader/Loader';
import useFetching from '../../hooks/useFetching';

export default function SinglePostPage() {
  const { id } = useParams();
  const [post, setPost] = useState({});
  const [fetchPostById, isLoading, error] = useFetching(async () => {
    const response = await PostService.getPostById(id);
    setPost(response.data);
  });

  useEffect(() => {
    fetchPostById(id);
  }, []);

  return (
    <div>
      <h1>You openned post witch id: {post.id}</h1>

      {isLoading ? (
        <Loader />
      ) : (
        <div>
          <h2>{post.title}</h2>
          <p>{post.body}</p>
        </div>
      )}
    </div>
  );
}
------------------/CODE-------------------

Пора отобразить список коментарием на странице детального отображения поста, хорошо, что jsonplaceholder предостовляет такой список по id коментария 
